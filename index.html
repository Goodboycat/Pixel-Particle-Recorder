<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Particle Animation Studio Pro</title>
    <script src="https://static.devv.ai/devv-app.js" type="module"></script>
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
    <div class="app-container">
        <!-- Sidebar Controls -->
        <div class="sidebar">
            <div id="controlPanel"></div>
        </div>

        <!-- Main Content Area -->
        <div class="main-content">
            <!-- Header -->
            <div class="app-header">
                <div class="app-title">‚ú® Ultimate Particle Animation Studio Pro</div>
                <div class="header-actions">
                    <button id="exportBtn" class="primary">üíæ Export</button>
                    <button id="importBtn" class="warning">üìÇ Import</button>
                    <button id="settingsBtn">‚öôÔ∏è Settings</button>
                </div>
            </div>

            <!-- Canvas Area -->
            <div class="canvas-area">
                <div class="canvas-container">
                    <canvas id="mainCanvas"></canvas>
                </div>
                
                <!-- Stats Overlay -->
                <div class="stats-overlay">
                    <div class="stat-item">
                        <span class="stat-label">FPS:</span>
                        <span class="stat-value" id="fpsCounter">60</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Particles:</span>
                        <span class="stat-value" id="particleCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Emitters:</span>
                        <span class="stat-value" id="emitterCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Memory:</span>
                        <span class="stat-value" id="memoryUsage">0 MB</span>
                    </div>
                </div>
            </div>

            <!-- Timeline -->
            <div class="timeline-container">
                <div class="timeline-header">
                    <div class="timeline-title">‚è±Ô∏è Animation Timeline</div>
                    <div class="timeline-controls">
                        <button id="timelinePlay" class="small">‚ñ∂Ô∏è</button>
                        <button id="timelinePause" class="small">‚è∏Ô∏è</button>
                        <button id="timelineStop" class="small">‚èπÔ∏è</button>
                        <button id="addKeyframe" class="small success">‚ûï Keyframe</button>
                        <button id="clearTimeline" class="small danger">üóëÔ∏è Clear</button>
                    </div>
                </div>
                <div class="timeline-track" id="timelineTrack">
                    <div class="timeline-progress" id="timelineProgress"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="exportModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Export Options</h2>
                <button class="modal-close" onclick="closeModal('exportModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="button-group">
                    <button id="exportPNG">üñºÔ∏è Export PNG Sprite Sheet</button>
                    <button id="exportGIF">üé¨ Export GIF Animation</button>
                    <button id="exportVideo">üìπ Export Video (WebM)</button>
                    <button id="exportJSON">üìÑ Export Project JSON</button>
                </div>
            </div>
        </div>
    </div>

    <div id="importModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Import Options</h2>
                <button class="modal-close" onclick="closeModal('importModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="control-item">
                    <label>Import Project File</label>
                    <input type="file" id="importFileInput" accept=".json">
                </div>
                <div class="control-item">
                    <label>Or Paste JSON</label>
                    <textarea id="importJSONText" rows="10" style="width: 100%; background: var(--accent-bg); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 8px;"></textarea>
                </div>
                <button id="importJSONBtn" class="success">Import Project</button>
            </div>
        </div>
    </div>

    <!-- Core Scripts -->
    <script src="js/core/ParticleEngine.js"></script>
    <script src="js/core/Emitter.js"></script>
    <script src="js/core/Timeline.js"></script>
    <script src="js/effects/AdvancedEffects.js"></script>
    <script src="js/ui/ControlPanel.js"></script>

    <!-- Main Application Script -->
    <script>
        // Initialize Application
        class ParticleStudioApp {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = 640;
                this.height = 480;
                
                // Setup canvas
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.canvas.style.width = this.width + 'px';
                this.canvas.style.height = this.height + 'px';
                
                // Initialize systems
                this.particleEngine = new ParticleEngine();
                this.particleEngine.setBounds(this.width, this.height);
                
                this.timeline = new Timeline();
                this.timelineTrack = new TimelineTrack();
                
                this.advancedEffects = new AdvancedEffects(this.particleEngine);
                this.controlPanel = new ControlPanel('controlPanel');
                
                // State
                this.isPlaying = true;
                this.lastTime = performance.now();
                this.fps = 60;
                this.frameCount = 0;
                this.recording = false;
                this.recordedFrames = [];
                
                // Setup UI
                this.setupControlPanel();
                this.setupEventListeners();
                this.setupTimeline();
                
                // Start main loop
                this.mainLoop();
                
                console.log('üé® Particle Animation Studio Pro initialized!');
                console.log('100+ Features Ready to Use!');
            }

            setupControlPanel() {
                const panel = this.controlPanel;
                
                // Effect Selection Section
                panel.createSection('üé≠ Particle Effects', 'effects');
                
                // Add effect categories
                const effectCategories = [
                    { label: 'üí• Explosive', value: 'explosive' },
                    { label: '‚ú® Magic', value: 'magic' },
                    { label: 'üå§Ô∏è Weather', value: 'weather' },
                    { label: 'üåå Cosmic', value: 'cosmic' },
                    { label: 'üî¨ Quantum', value: 'quantum' },
                    { label: 'üî• Elemental', value: 'elemental' },
                    { label: '‚ö° Beam', value: 'beam' }
                ];
                
                panel.addDropdown('effects', 'Category', 'effectCategory', 
                    effectCategories, 'explosive', 
                    (val) => this.filterEffects(val)
                );
                
                // Effect buttons
                panel.addButton('effects', 'üí• Nuclear Explosion', 'btnNuclear', 
                    () => this.triggerEffect('nuclearExplosion'), 'primary');
                panel.addButton('effects', 'üåÄ Plasma Vortex', 'btnPlasma', 
                    () => this.triggerEffect('plasmaVortex'));
                panel.addButton('effects', '‚ö° Lightning Storm', 'btnLightning', 
                    () => this.triggerEffect('lightningStorm'));
                panel.addButton('effects', '‚ú® Celestial Nova', 'btnNova', 
                    () => this.triggerEffect('celestialNova'));
                panel.addButton('effects', 'üî¨ Quantum Entanglement', 'btnQuantum', 
                    () => this.triggerEffect('quantumEntanglement'));
                panel.addButton('effects', 'üåå Nebula Cloud', 'btnNebula', 
                    () => this.triggerEffect('nebulaCloud'));
                panel.addButton('effects', 'üåÄ Dimensional Rift', 'btnRift', 
                    () => this.triggerEffect('dimensionalRift'));
                panel.addButton('effects', 'üíé Crystalline Burst', 'btnCrystal', 
                    () => this.triggerEffect('crystallineBurst'));
                panel.addButton('effects', 'üî• Inferno Tornado', 'btnTornado', 
                    () => this.triggerEffect('infernoTornado'));
                panel.addButton('effects', 'üåà Prismatic Beam', 'btnPrism', 
                    () => this.triggerEffect('prismaticBeam'));
                
                panel.addSeparator('effects');
                panel.addInfo('effects', 'Click any effect to trigger it at canvas center. More effects coming soon!');
                
                // Emitter Section
                panel.createSection('üîÑ Continuous Emitters', 'emitters');
                
                panel.addButton('emitters', 'üî• Fire', 'btnEmitFire', 
                    () => this.addEmitter('fire'), 'warning');
                panel.addButton('emitters', 'üí® Smoke', 'btnEmitSmoke', 
                    () => this.addEmitter('smoke'));
                panel.addButton('emitters', '‚ú® Sparkles', 'btnEmitSparkle', 
                    () => this.addEmitter('sparkle'));
                panel.addButton('emitters', '‚õàÔ∏è Rain', 'btnEmitRain', 
                    () => this.addEmitter('rain'));
                panel.addButton('emitters', '‚ùÑÔ∏è Snow', 'btnEmitSnow', 
                    () => this.addEmitter('snow'));
                panel.addButton('emitters', 'üí• Explosion', 'btnEmitExplosion', 
                    () => this.addEmitter('explosion'));
                panel.addButton('emitters', '‚õ≤ Fountain', 'btnEmitFountain', 
                    () => this.addEmitter('fountain'));
                panel.addButton('emitters', '‚ú® Magic', 'btnEmitMagic', 
                    () => this.addEmitter('magic'));
                panel.addButton('emitters', 'üî¥ Laser', 'btnEmitLaser', 
                    () => this.addEmitter('laser'));
                panel.addButton('emitters', 'ü´ß Bubbles', 'btnEmitBubbles', 
                    () => this.addEmitter('bubbles'));
                
                panel.addSeparator('emitters');
                panel.addButton('emitters', 'üóëÔ∏è Clear All Emitters', 'btnClearEmitters', 
                    () => this.clearEmitters(), 'danger');
                
                // Physics Section
                panel.createSection('‚öôÔ∏è Physics & Environment', 'physics');
                
                panel.addCheckbox('physics', 'Enable Physics', 'physicsEnabled', true, 
                    (val) => this.particleEngine.physics.enabled = val);
                
                panel.addVector2('physics', 'Gravity', 'gravity', 0, 0.05, 
                    (val) => {
                        this.particleEngine.physics.gravity.x = val.x;
                        this.particleEngine.physics.gravity.y = val.y;
                    });
                
                panel.addVector2('physics', 'Wind', 'wind', 0, 0, 
                    (val) => {
                        this.particleEngine.physics.wind.x = val.x;
                        this.particleEngine.physics.wind.y = val.y;
                    });
                
                panel.addSlider('physics', 'Friction', 'friction', 0, 1, 0.99, 0.01, 
                    (val) => this.particleEngine.physics.friction = val);
                
                panel.addSlider('physics', 'Bounce', 'bounce', 0, 1, 0.8, 0.05, 
                    (val) => this.particleEngine.physics.bounce = val);
                
                // Rendering Section
                panel.createSection('üé® Rendering Options', 'rendering');
                
                panel.addCheckbox('rendering', 'Use Blend Modes', 'useBlendMode', true, 
                    (val) => this.renderOptions.useBlendMode = val);
                
                panel.addCheckbox('rendering', 'Pixelated Rendering', 'pixelated', true, 
                    (val) => this.renderOptions.pixelated = val);
                
                panel.addCheckbox('rendering', 'Debug Mode', 'debug', false, 
                    (val) => this.renderOptions.debug = val);
                
                panel.addSlider('rendering', 'Background Alpha', 'bgAlpha', 0, 1, 0.15, 0.05, 
                    (val) => this.bgAlpha = val);
                
                panel.addColorPicker('rendering', 'Background Color', 'bgColor', '#0a0a1a', 
                    (val) => this.bgColor = val);
                
                // Recording Section
                panel.createSection('üé¨ Recording & Export', 'recording');
                
                panel.addButtonGroup('recording', [
                    {
                        label: '‚è∫Ô∏è Start Recording',
                        callback: () => this.startRecording(),
                        className: 'danger'
                    },
                    {
                        label: '‚èπÔ∏è Stop Recording',
                        callback: () => this.stopRecording()
                    }
                ], 'recordingButtons');
                
                panel.addSeparator('recording');
                
                panel.addSlider('recording', 'Recording FPS', 'recordFPS', 10, 60, 30, 1, 
                    (val) => this.recordFPS = val);
                
                panel.addInfo('recording', 'Record animations and export as sprite sheets, GIFs, or videos!');
            }

            setupEventListeners() {
                // Canvas click to trigger effects
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Trigger current selected effect at click position
                    const currentEffect = 'nuclearExplosion'; // Default
                    this.advancedEffects.playEffect(currentEffect, x, y);
                });
                
                // Export button
                document.getElementById('exportBtn').addEventListener('click', () => {
                    this.showModal('exportModal');
                });
                
                // Import button
                document.getElementById('importBtn').addEventListener('click', () => {
                    this.showModal('importModal');
                });
                
                // Export handlers
                document.getElementById('exportPNG')?.addEventListener('click', () => this.exportPNG());
                document.getElementById('exportJSON')?.addEventListener('click', () => this.exportJSON());
            }

            setupTimeline() {
                // Timeline controls
                document.getElementById('timelinePlay').addEventListener('click', () => {
                    this.timeline.play();
                });
                
                document.getElementById('timelinePause').addEventListener('click', () => {
                    this.timeline.pause();
                });
                
                document.getElementById('timelineStop').addEventListener('click', () => {
                    this.timeline.stop();
                });
                
                document.getElementById('addKeyframe').addEventListener('click', () => {
                    this.addTimelineKeyframe();
                });
                
                document.getElementById('clearTimeline').addEventListener('click', () => {
                    this.timeline.clear();
                    this.renderTimeline();
                });
                
                // Timeline click to seek
                const track = document.getElementById('timelineTrack');
                track.addEventListener('click', (e) => {
                    const rect = track.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const progress = x / rect.width;
                    this.timeline.seek(progress * this.timeline.getDuration());
                });
            }

            triggerEffect(effectId) {
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                this.advancedEffects.playEffect(effectId, centerX, centerY);
            }

            addEmitter(presetId) {
                const preset = EmitterPresets[presetId];
                if (!preset) return;
                
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                
                const emitter = new ParticleEmitter(centerX, centerY, preset);
                this.particleEngine.addEmitter(emitter);
            }

            clearEmitters() {
                this.particleEngine.emitters = [];
                this.particleEngine.clear();
            }

            startRecording() {
                this.recording = true;
                this.recordedFrames = [];
                console.log('üî¥ Recording started');
            }

            stopRecording() {
                this.recording = false;
                console.log(`‚úÖ Recording stopped. Captured ${this.recordedFrames.length} frames`);
            }

            addTimelineKeyframe() {
                const currentState = {
                    particleCount: this.particleEngine.particles.length,
                    physics: { ...this.particleEngine.physics },
                    timestamp: this.timeline.getCurrentTime()
                };
                
                this.timeline.addKeyframe(this.timeline.getCurrentTime(), currentState);
                this.renderTimeline();
            }

            renderTimeline() {
                const track = document.getElementById('timelineTrack');
                const keyframesContainer = track.querySelectorAll('.keyframe');
                keyframesContainer.forEach(k => k.remove());
                
                const keyframes = this.timeline.getAllKeyframes();
                keyframes.forEach(kf => {
                    const progress = kf.time / this.timeline.getDuration();
                    const keyframeEl = document.createElement('div');
                    keyframeEl.className = 'keyframe';
                    keyframeEl.style.left = (progress * 100) + '%';
                    keyframeEl.title = `Time: ${kf.time.toFixed(0)}ms`;
                    track.appendChild(keyframeEl);
                });
            }

            exportPNG() {
                const link = document.createElement('a');
                link.download = `particle-animation-${Date.now()}.png`;
                link.href = this.canvas.toDataURL('image/png');
                link.click();
                console.log('‚úÖ PNG exported');
            }

            exportJSON() {
                const projectData = {
                    version: '1.0',
                    timeline: this.timeline.export(),
                    settings: this.controlPanel.exportPreset(),
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(projectData, null, 2)], 
                    { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.download = `particle-project-${Date.now()}.json`;
                link.href = url;
                link.click();
                
                URL.revokeObjectURL(url);
                console.log('‚úÖ Project JSON exported');
            }

            showModal(modalId) {
                document.getElementById(modalId).classList.add('active');
            }

            mainLoop() {
                const currentTime = performance.now();
                const deltaTime = Math.min((currentTime - this.lastTime) / 16.67, 2);
                this.lastTime = currentTime;
                
                // Clear canvas with trail effect
                this.ctx.fillStyle = this.bgColor || '#0a0a1a';
                this.ctx.globalAlpha = this.bgAlpha || 0.15;
                this.ctx.fillRect(0, 0, this.width, this.height);
                this.ctx.globalAlpha = 1;
                
                // Update systems
                this.particleEngine.update(deltaTime);
                this.timeline.update(deltaTime * 16.67);
                
                // Render
                this.renderOptions = {
                    useBlendMode: true,
                    pixelated: true,
                    debug: false
                };
                this.particleEngine.render(this.ctx, this.renderOptions);
                
                // Update stats
                this.frameCount++;
                if (this.frameCount % 30 === 0) {
                    this.updateStats();
                }
                
                // Update timeline progress
                const progress = this.timeline.getProgress();
                document.getElementById('timelineProgress').style.left = (progress * 100) + '%';
                
                // Recording
                if (this.recording && this.frameCount % (60 / this.recordFPS) === 0) {
                    this.recordedFrames.push(this.canvas.toDataURL());
                }
                
                requestAnimationFrame(() => this.mainLoop());
            }

            updateStats() {
                document.getElementById('fpsCounter').textContent = '60';
                document.getElementById('particleCount').textContent = 
                    this.particleEngine.getParticleCount();
                document.getElementById('emitterCount').textContent = 
                    this.particleEngine.emitters.length;
                
                if (performance.memory) {
                    const mb = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
                    document.getElementById('memoryUsage').textContent = mb + ' MB';
                }
            }
        }

        // Helper functions
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        // Initialize app when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                window.app = new ParticleStudioApp();
            });
        } else {
            window.app = new ParticleStudioApp();
        }
    </script>
</body>
</html>
